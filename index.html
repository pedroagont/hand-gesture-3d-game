<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Hand Gesture 3D Game</title>
    <style>
      body {
        margin: 0;
        padding: 0;
        background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        font-family: Arial, sans-serif;
        overflow: hidden;
      }

      #gameContainer {
        position: relative;
        width: 100vw;
        height: 100vh;
      }

      #gameCanvas {
        display: block;
      }

      #videoContainer {
        position: absolute;
        top: 10px;
        right: 10px;
        width: 200px;
        height: 150px;
        border: 3px solid #fff;
        border-radius: 10px;
        overflow: hidden;
        z-index: 100;
      }

      #video {
        width: 100%;
        height: 100%;
        object-fit: cover;
        transform: scaleX(-1);
      }

      #ui {
        position: absolute;
        top: 10px;
        left: 10px;
        color: white;
        font-size: 18px;
        font-weight: bold;
        z-index: 100;
      }

      #instructions {
        position: absolute;
        bottom: 10px;
        left: 50%;
        transform: translateX(-50%);
        color: white;
        text-align: center;
        z-index: 100;
        background: rgba(0, 0, 0, 0.5);
        padding: 10px;
        border-radius: 10px;
      }

      #startButton {
        position: absolute;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        padding: 20px 40px;
        font-size: 24px;
        background: linear-gradient(45deg, #ff6b6b, #4ecdc4);
        color: white;
        border: none;
        border-radius: 15px;
        cursor: pointer;
        z-index: 200;
        box-shadow: 0 8px 25px rgba(0, 0, 0, 0.3);
        transition: all 0.3s ease;
      }

      #startButton:hover {
        transform: translate(-50%, -50%) scale(1.05);
        box-shadow: 0 12px 35px rgba(0, 0, 0, 0.4);
      }

      .gesture-indicator {
        position: absolute;
        top: 180px;
        right: 10px;
        background: rgba(255, 255, 255, 0.9);
        padding: 10px;
        border-radius: 10px;
        font-weight: bold;
        z-index: 100;
      }
    </style>
  </head>
  <body>
    <div id="gameContainer">
      <canvas id="gameCanvas"></canvas>

      <div id="videoContainer" style="display: none">
        <video id="video" autoplay muted></video>
      </div>

      <div id="ui" style="display: none">
        <div>Score: <span id="score">0</span></div>
        <div>Target: <span id="target">Red</span></div>
      </div>

      <div id="instructions" style="display: none">
        <div>Use hand gestures to move your character!</div>
        <div>ðŸ‘† Point up to move forward | âœ‹ Open palm to move back</div>
        <div>ðŸ‘‰ Point right/left to turn | Collect the colored orbs!</div>
      </div>

      <div
        class="gesture-indicator"
        id="gestureIndicator"
        style="display: none"
      >
        Gesture: <span id="currentGesture">None</span>
      </div>

      <button id="startButton">Start Game</button>
    </div>

    <script
      src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"
      type="text/javascript"
    ></script>
    <!-- <script src="https://unpkg.com/ml5@1/dist/ml5.min.js"></script> -->
    <script src="https://unpkg.com/ml5@0.12.2/dist/ml5.min.js"></script>

    <script>
      // Game variables
      let scene,
        camera,
        renderer,
        player,
        orbs = [];
      let handpose,
        video,
        predictions = [];
      let gameStarted = false;
      let score = 0;
      let targetColor = "red";
      let currentGesture = "none";

      // Game colors
      const colors = {
        red: 0xff6b6b,
        blue: 0x4dabf7,
        green: 0x51cf66,
        yellow: 0xffd43b,
        purple: 0xcc5de8,
      };

      const colorNames = Object.keys(colors);

      // Initialize the game
      function init() {
        // Create scene
        scene = new THREE.Scene();
        scene.background = new THREE.Color(0x87ceeb);

        // Create camera
        camera = new THREE.PerspectiveCamera(
          75,
          window.innerWidth / window.innerHeight,
          0.1,
          1000
        );
        camera.position.set(0, 5, 10);

        // Create renderer
        renderer = new THREE.WebGLRenderer({
          canvas: document.getElementById("gameCanvas"),
        });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.PCFSoftShadowMap;

        // Add lighting
        const ambientLight = new THREE.AmbientLight(0x404040, 0.4);
        scene.add(ambientLight);

        const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
        directionalLight.position.set(5, 10, 5);
        directionalLight.castShadow = true;
        scene.add(directionalLight);

        // Create player
        const playerGeometry = new THREE.SphereGeometry(2, 32, 32);
        const playerMaterial = new THREE.MeshLambertMaterial({
          color: 0x00ff00,
        });
        player = new THREE.Mesh(playerGeometry, playerMaterial);
        player.position.y = 0.5;
        player.castShadow = true;
        scene.add(player);

        // Create ground
        const groundGeometry = new THREE.PlaneGeometry(50, 50);
        const groundMaterial = new THREE.MeshLambertMaterial({
          color: 0x90ee90,
        });
        const ground = new THREE.Mesh(groundGeometry, groundMaterial);
        ground.rotation.x = -Math.PI / 2;
        ground.receiveShadow = true;
        scene.add(ground);

        // Create initial orbs
        spawnOrbs();

        // Set random target color
        setRandomTarget();

        // Start game loop
        animate();
      }

      // Spawn random orbs
      function spawnOrbs() {
        // Clear existing orbs
        orbs.forEach((orb) => scene.remove(orb));
        orbs = [];

        for (let i = 0; i < 10; i++) {
          const orbGeometry = new THREE.SphereGeometry(1, 16, 16);
          const colorName =
            colorNames[Math.floor(Math.random() * colorNames.length)];
          const orbMaterial = new THREE.MeshLambertMaterial({
            color: colors[colorName],
            emissive: colors[colorName],
            emissiveIntensity: 0.3,
          });

          const orb = new THREE.Mesh(orbGeometry, orbMaterial);
          orb.position.x = (Math.random() - 0.5) * 40;
          orb.position.y = 0.5;
          orb.position.z = (Math.random() - 0.5) * 40;
          orb.userData = { color: colorName };
          orb.castShadow = true;

          scene.add(orb);
          orbs.push(orb);
        }
      }

      // Set random target color
      function setRandomTarget() {
        targetColor = colorNames[Math.floor(Math.random() * colorNames.length)];
        document.getElementById("target").textContent =
          targetColor.charAt(0).toUpperCase() + targetColor.slice(1);
      }

      // Setup camera and ML5 handpose
      async function setupCamera() {
        const video = document.getElementById("video");

        // Important for iOS Safari: prevent fullscreen takeover
        video.setAttribute("playsinline", "");
        video.setAttribute("autoplay", "");
        video.setAttribute("muted", ""); // Required for autoplay without user gesture

        try {
          const stream = await navigator.mediaDevices.getUserMedia({
            video: {
              facingMode: "user", // front camera
              width: { ideal: 640 },
              height: { ideal: 480 },
            },
            audio: false,
          });

          video.srcObject = stream;

          await video.play(); // Ensure playback starts

          // Initialize handpose once video is ready
          video.onloadedmetadata = () => {
            handpose = ml5.handpose(video, () => {
              console.log("Handpose model loaded");
              handpose.on("predict", (results) => {
                predictions = results;
                processHandGesture();
              });
            });
          };
        } catch (error) {
          console.error("Error accessing camera:", error);
          alert("Camera access required for hand gesture control!");
        }
      }

      // Process hand gestures
      function processHandGesture() {
        if (predictions.length > 0 && gameStarted) {
          const hand = predictions[0];
          const landmarks = hand.landmarks;

          // console.log(landmarks);

          // Get key landmark positions
          const wrist = landmarks[0];
          const thumbTip = landmarks[4];
          const indexTip = landmarks[8];
          const middleTip = landmarks[12];
          const ringTip = landmarks[16];
          const pinkyTip = landmarks[20];

          // Detect gestures based on finger positions
          const gesture = detectGesture(landmarks);
          currentGesture = gesture;
          document.getElementById("currentGesture").textContent = gesture;

          // Move player based on gesture
          movePlayer(gesture);
        }
      }

      // Simple gesture detection
      function detectGesture(landmarks) {
        const wrist = landmarks[0];
        const indexTip = landmarks[8];
        const indexPip = landmarks[6];
        const middleTip = landmarks[12];
        const thumbTip = landmarks[4];

        // Check if index finger is pointing up
        if (indexTip[1] < indexPip[1] - 20 && middleTip[1] > indexPip[1]) {
          return "point_up";
        }

        // Check if hand is open (all fingers extended)
        const fingersUp = [
          landmarks[4][1] < landmarks[3][1], // thumb
          landmarks[8][1] < landmarks[6][1], // index
          landmarks[12][1] < landmarks[10][1], // middle
          landmarks[16][1] < landmarks[14][1], // ring
          landmarks[20][1] < landmarks[18][1], // pinky
        ].filter((f) => f).length;

        if (fingersUp >= 4) {
          return "open_palm";
        }

        // Check pointing left or right
        if (indexTip[1] < indexPip[1] - 10) {
          if (indexTip[0] > wrist[0] - 50) {
            return "point_left";
          } else if (indexTip[0] < wrist[0] + 50) {
            return "point_right";
          }
        }

        return "none";
      }

      // Move player based on gesture
      function movePlayer(gesture) {
        const speed = 0.2;

        switch (gesture) {
          case "point_up":
            player.position.z -= speed;
            break;
          case "open_palm":
            player.position.z += speed;
            break;
          case "point_left":
            player.position.x -= speed;
            break;
          case "point_right":
            player.position.x += speed;
            break;
        }

        // Keep player within bounds
        player.position.x = Math.max(-20, Math.min(20, player.position.x));
        player.position.z = Math.max(-20, Math.min(20, player.position.z));
      }

      // Check collisions
      function checkCollisions() {
        for (let i = orbs.length - 1; i >= 0; i--) {
          const orb = orbs[i];
          const distance = player.position.distanceTo(orb.position);

          if (distance < 0.8) {
            // Collision detected
            scene.remove(orb);
            orbs.splice(i, 1);

            if (orb.userData.color === targetColor) {
              // Correct color - increase score
              score += 10;
              document.getElementById("score").textContent = score;

              // Set new target
              setRandomTarget();

              // Spawn new orb
              spawnSingleOrb();
            } else {
              // Wrong color - decrease score
              score = Math.max(0, score - 5);
              document.getElementById("score").textContent = score;
            }
          }
        }
      }

      // Spawn a single orb
      function spawnSingleOrb() {
        const orbGeometry = new THREE.SphereGeometry(0.3, 16, 16);
        const colorName =
          colorNames[Math.floor(Math.random() * colorNames.length)];
        const orbMaterial = new THREE.MeshLambertMaterial({
          color: colors[colorName],
          emissive: colors[colorName],
          emissiveIntensity: 0.3,
        });

        const orb = new THREE.Mesh(orbGeometry, orbMaterial);
        orb.position.x = (Math.random() - 0.5) * 40;
        orb.position.y = 0.5;
        orb.position.z = (Math.random() - 0.5) * 40;
        orb.userData = { color: colorName };
        orb.castShadow = true;

        scene.add(orb);
        orbs.push(orb);
      }

      // Animation loop
      function animate() {
        requestAnimationFrame(animate);

        if (gameStarted) {
          // Animate orbs (floating effect)
          orbs.forEach((orb, index) => {
            orb.position.y = 0.5 + Math.sin(Date.now() * 0.003 + index) * 0.2;
            orb.rotation.y += 0.02;
          });

          // Check collisions
          checkCollisions();

          // Update camera to follow player
          camera.position.x = player.position.x;
          camera.position.z = player.position.z + 10;
          camera.lookAt(player.position);
        }

        renderer.render(scene, camera);
      }

      // Start game
      document
        .getElementById("startButton")
        .addEventListener("click", async () => {
          document.getElementById("startButton").style.display = "none";
          document.getElementById("ui").style.display = "block";
          document.getElementById("instructions").style.display = "block";
          document.getElementById("videoContainer").style.display = "block";
          document.getElementById("gestureIndicator").style.display = "block";

          await setupCamera();
          gameStarted = true;
        });

      // Handle window resize
      window.addEventListener("resize", () => {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
      });

      // Initialize the game
      init();
    </script>
  </body>
</html>
